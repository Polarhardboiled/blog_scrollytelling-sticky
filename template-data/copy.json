{"hed":"Easier scrollytelling with position sticky","dek":"Leaning on CSS to simplify the process.","sections":[{"id":"intro","text":[{"type":"text","value":"We‚Äôve written a lot about scrollytelling here at The Pudding. We‚Äôve covered everything from a <a href=https://pudding.cool/process/how-to-implement-scrollytelling/ target=_blank>library comparison</a>, to <a href=https://pudding.cool/process/responsive-scrollytelling/ target=_blank>responsive best practices</a>, to a <a href=https://pudding.cool/process/introducing-scrollama/ target=_blank>deep-dive into Scrollama</a>. But there is always room for improvement. Usually the biggest implementation pain with scrollytelling is the <em>sticky graphic pattern</em>, whereby the graphic scrolls into view, becomes ‚Äústuck‚Äù for a duration of steps, then exits and ‚Äúunsticks‚Äù when the steps conclude."},{"type":"text","value":"<strong>This post will focus on the easiest development solution we‚Äôve come up with yet: offloading this complexity to CSS, using</strong> <code>position: sticky</code>."}]},{"id":"why","hed":"Why use Sticky?","text":[{"type":"text","value":"The short version: when using the sticky graphic pattern, you need a bunch of JavaScript to handle the stuck state, dimensions, etc.. With this approach, that is all done with (minimal) CSS. This means less bugs, less maintenance, and more happiness."}]},{"id":"sticky","hed":"What is Sticky?","text":[{"type":"text","value":"<a href=https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky_positioning>Sticky positioning</a> is the love child of <code>position: relative</code> and <code>position: fixed</code> (in which said love child grows up to do bigger and better things while still retaining the lessons of its parents). An element with a <code>position: sticky</code> declaration remains static in the document until a certain threshold is reached, and then it becomes fixed once scrolled to that threshold</a>. A <em>threshold</em> is defined by any directional declaration such as: <code>top: 0;</code>, which becomes fixed once the element reaches the top edge of its parent."},{"type":"text","value":"A sticky element is always relatively positioned to its parent (much like <code>position: absolute;</code>). This means that these elements will stick and unstick only within the bounds of its parent element, not the viewport; it also means that the thresholds are marked by the edges of the parent. The great thing about this constraint is that you can control the overlap (or lack thereof) of multiple stuck elements."}]},{"id":"demo","hed":"In Action","text":[{"type":"text","value":"And now for the good stuff. The first sticky graphic employs the classic side-by-side approach. Scroll on."}]},{"id":"scrolly-side","text":[{"type":"text","value":"The second graphic showcases the overlay approach. Keep on scrolling!"}]},{"id":"scrolly-overlay","text":[{"type":"text","value":"The sticky graphic is entirely handled by CSS, while the only thing done in JavaScript is handling the step triggers. We chose to use <a href=https://github.com/russellgoldenberg/enter-view target=_blank>enter-view.js</a> here because it has an incredibly simple interface, super lightweight, and Russell wrote it üòÄ. However, any trigger library will work, be it <a href=http://imakewebthings.com/waypoints/ target=_blank>Waypoints</a>, <a href=https://github.com/russellgoldenberg/scrollama target=_blank>Scrollama</a>, or another library."}]},{"id":"code","hed":"The Code","text":[{"type":"text","value":"Below is the core HTML, CSS and JavaScript that makes this work, excluding the code for aesthetics. You can view the full code for these examples on <a href=https://codepen.io/collection/XBWPqE/ target=_blank>codepen</a> or <a href=https://github.com/the-pudding/blog_scrollytelling-sticky target=_blank>github</a> for the this full article."}]},{"id":"code-html"},{"id":"code-css"},{"id":"code-js"},{"id":"conclusion","hed":"Wrap Up","text":[{"type":"text","value":"You can still implement this behavior in JavaScript, but <code>position: sticky</code> has a few core benefits which give it the upper hand when it comes to development. Scroll listeners in JavaScript aren‚Äôt always the best solution: they can inhibit performance and are sometimes quite janky. Depending on the speed of scroll and the device someone is using, the listener might fall out-of-sync and need to catch up with a scroll, causing an element to jump into place instead of displaying a smooth locking behavior. Beyond performance concerns, it‚Äôs much simpler to write 2 lines of CSS than a bunch of JavaScript."},{"type":"text","value":"But is it well-supported? <a href=https://caniuse.com/#feat=css-sticky>Yes it is!</a> Apart from a few minor bugs with <code>thead</code> and <code>tr</code> elements, it‚Äôs good to go across the latest versions of all major browsers. IE doesn‚Äôt support this feature (<em>ugh, of course...</em>), but there are a <a href=https://github.com/wilddeer/stickyfill>few polyfills</a> and <a href=https://github.com/dollarshaveclub/stickybits>companions</a> out there with loose support for certain directional thresholds. If polyfills aren‚Äôt your jam or the ones available just aren‚Äôt cutting it, you can always‚Ä¶ do nothing! The beauty of <code>position: sticky</code> is that it has built-in graceful degradation; if a browser doesn‚Äôt support it, the element will stay static in the source order it was added. And if you want to get extra fancy, you can use a <a href=https://hacks.mozilla.org/2016/08/using-feature-queries-in-css/>feature query</a> <code>@supports (position: sticky)</code> and implement a fallback layout."}]}]}